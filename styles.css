// Script orchestrates the interaction flow: open -> reveal text -> blink & ring -> mascot -> robot
(function(){
  const box = document.getElementById('goldenBox');
  const reveal = document.getElementById('reveal');
  const ring = document.getElementById('ring');
  const mascot = document.getElementById('mascot');
  const robot = document.getElementById('robot');
  const audioToggle = document.getElementById('audioToggle');
  const resetBtn = document.getElementById('resetBtn');

  // Timings (ms) for sequence; tweak to taste
  const TIMINGS = {
    openMs: 420,
    revealDelay: 420,
    revealVisibleMs: 1800,
    afterRevealDelay: 380,
    mascotShowMs: 420,
    mascotMoveMs: 1200,
    morphDelay: 1400
  };

  // Audio setup (optional shimmering sounds)
  let audioCtx = null;
  function ensureAudio(){
    if(audioCtx) return;
    try{
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }catch(e){
      audioCtx = null;
    }
  }
  function playTapShimmer(){
    if(!audioToggle.checked) return;
    ensureAudio();
    if(!audioCtx) return;
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    // quick shimmer: descending chirp
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, t);
    osc.frequency.exponentialRampToValueAtTime(320, t + 0.18);
    gain.gain.setValueAtTime(0.001, t);
    gain.gain.exponentialRampToValueAtTime(0.08, t + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.0005, t + 0.22);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    osc.stop(t + 0.25);
  }

  function playAmbientTone(){
    if(!audioToggle.checked) return;
    ensureAudio();
    if(!audioCtx) return;
    // a faint, slowly pulsing background tone (not looping here to keep it lightweight)
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = 140;
    gain.gain.value = 0.0005;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(t);
    // fade out slowly; short-lived so it doesn't persist forever
    gain.gain.exponentialRampToValueAtTime(0.00005, t + 6);
    osc.stop(t + 6.2);
  }

  // Utility: set aria-pressed
  function setPressed(val){
    box.setAttribute('aria-pressed', val ? 'true' : 'false');
  }

  // Reset everything to initial state
  function resetState(){
    // remove all classes and hide elements
    box.classList.remove('open', 'glow-blink');
    reveal.classList.remove('visible');
    ring.classList.remove('active');
    mascot.classList.remove('visible','moving');
    robot.classList.remove('visible');
    setPressed(false);
  }

  // Sequence when box is clicked/tapped
  let isAnimating = false;
  async function startSequence(){
    if(isAnimating) return; // prevent overlapping sequences
    isAnimating = true;

    playTapShimmer();

    // open / pop
    box.classList.add('open');
    setPressed(true);

    await wait(TIMINGS.openMs);

    // reveal headline
    reveal.classList.add('visible');
    playAmbientTone();

    await wait(TIMINGS.revealVisibleMs);

    // begin blinking box and ring
    box.classList.add('glow-blink');
    ring.classList.add('active');

    await wait(TIMINGS.afterRevealDelay);

    // show mascot and start side-to-side move
    mascot.classList.add('visible');
    // small pause then start moving
    await wait(200);
    mascot.classList.add('moving');

    // allow mascot to move for a while then morph to robot
    await wait(TIMINGS.mascotMoveMs);

    // morph: fade mascot out, show robot
    mascot.classList.remove('moving');
    mascot.classList.remove('visible');
    robot.classList.add('visible');

    // keep robot coding motion; when finished, leave glowing state on box
    await wait(TIMINGS.morphDelay);

    // allow user to repeat; we keep glow and ring active
    isAnimating = false;
  }

  // small helper: promise-based timeout
  function wait(ms){ return new Promise(r => setTimeout(r, ms)); }

  // event handlers
  box.addEventListener('click', (e) => {
    startSequence();
  });

  box.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' || e.key === ' '){
      e.preventDefault();
      startSequence();
    }
  });

  resetBtn.addEventListener('click', (e) => {
    resetState();
  });

  // On load: reset to ensure consistent state
  resetState();

  // reduced-motion fallback: if user prefers reduced-motion, show static fallback (no animations)
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  if(prefersReduced){
    // make everything visible but non-animated: static fallback
    reveal.classList.add('visible');
    mascot.classList.add('visible');
    robot.classList.add('visible');
    ring.classList.add('active');
    box.classList.add('glow-blink');
  }

  // small helper: unlock audio on first user gesture if necessary
  window.addEventListener('pointerdown', () => {
    if(!audioCtx && audioToggle.checked){
      try{
        ensureAudio();
        if(audioCtx && audioCtx.state === 'suspended'){
          audioCtx.resume();
        }
      }catch(e){}
    }
  }, { once: true });

  // initial keyboard accessibility focus ring
  box.addEventListener('focus', () => box.classList.add('focus'));
  box.addEventListener('blur', () => box.classList.remove('focus'));

})();
